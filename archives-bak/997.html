
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>super | 青春部落    </title>
    <meta name="keywords"  content="" />
    <meta name="description"  content="" />
    <link rel="stylesheet" type="text/css" media="all" href="https://cn-blogs.cn/wp-content/themes/pencilone/style.css" />
    <link rel="profile" href="http://gmpg.org/xfn/11">
    <link rel="pingback" href="https://cn-blogs.cn/xmlrpc.php">
    <link id="favicon" href="/favicon.ico" rel="icon" type="image/x-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="青春部落 &raquo; super评论Feed" href="https://cn-blogs.cn/archives/997.html/feed" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/cn-blogs.cn\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.9.1"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55358,56794,8205,9794,65039],[55358,56794,8203,9794,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='https://api.w.org/' href='https://cn-blogs.cn/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://cn-blogs.cn/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://cn-blogs.cn/wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='traceback' href='https://cn-blogs.cn/archives/994.html' />
<link rel='next' title='tornado options 配置选项' href='https://cn-blogs.cn/archives/1000.html' />
<meta name="generator" content="WordPress 4.9.1" />
<link rel="canonical" href="https://cn-blogs.cn/archives/997.html" />
<link rel='shortlink' href='https://cn-blogs.cn/?p=997' />
<link rel="alternate" type="application/json+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F997.html" />
<link rel="alternate" type="text/xml+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F997.html&#038;format=xml" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-32x32.png" sizes="32x32" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-180x180.png" />
<meta name="msapplication-TileImage" content="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-270x270.png" />

<meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">


</head>

<body class="post-template-default single single-post postid-997 single-format-standard">
<header class="navbar">
<div class="container">
    <div class="navbar-brand">
        <img src="/logo.png" width="73" height="88">
        <div>
        <h1 class="title2 is-3 navbar-item">
            <a href="https://cn-blogs.cn/" rel="home">青春部落</a>
        </h1>
        <p class="has-text-right">
            <a href="/">记录生活的足迹</a>
        </p>
        </div>
    </div>
    <div class="navbar-menu is-active">
    <div class="navbar-end">
    <div class="tabs is-right">
    <a class="navbar-item" href="/pages/index.html">索引</a>
    <a class="navbar-item" href="/about">About</a>
    </div>
    </div>
    </div>
</div>
</header>


<main class="container">
        <article class="article margin-top20">

        <!-- 文章分类和上一篇\下一篇 -->
        <div class="box columns">
            <!-- 文章分类 -->
            <div class="column is-two-fifth">
                <div class="categproe-name">分类：</div>
                <ul class="post-categories">
	<li><a href="https://cn-blogs.cn/archives/category/development/python" rel="category tag">Python</a></li></ul>            </div>
            <!-- 文章分类结束 -->

            <!-- 上一篇和下一篇 -->
            <div class="column is-two-fifth is-offset-5">
                
	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">Post navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://cn-blogs.cn/archives/994.html" rel="prev">上一篇：traceback</a></div><div class="nav-next"><a href="https://cn-blogs.cn/archives/1000.html" rel="next">下一篇：tornado options 配置选项</a></div></div>
	</nav>            </div>
            <!-- 上一篇和下一篇结束 -->
        </div>

        <!-- 文章信息 -->
        <!-- 文章标题 -->
        <div class="title is-3 has-text-centered">
            super        </div>
        <!-- 文章标题结束 -->

        <!-- 文章作者、发布时间、更新时间 -->
        <div class="subtitle is-5 has-text-centered">
            <span class="entry-author"><a href="https://cn-blogs.cn/archives/author/admin" title="由admin发布" rel="author">admin</a></span>
            <span class="entry-date">2016/11/09</span>
            <span class="update is-hidden">2016-12-28</span>
        </div>
        <!-- 文章作者、发布时间、更新时间结束 -->

        <!-- 文章内容 -->
        <div class="content article-body">
            <div class="content">
                <p>简单说, super函数是调用下一个父类(超类)并返回该父类实例的方法. 这里的下一个的概念参考后面的MRO表介绍.<br />
<strong>help介绍如下:</strong><br />
super(type, obj) -&gt; bound super object; requires isinstance(obj, type)<br />
super(type) -&gt; unbound super object<br />
super(type, type2) -&gt; bound super object; requires issubclass(type2, type)<br />
Typical use to call a cooperative superclass method:</p>
<p>class C(B):<br />
&#8212;-def meth(self, arg):<br />
&#8212;&#8212;&#8211;super(C, self).meth(arg)<br />
由此可知,<br />
super有三种用法,<br />
第一参数总是召唤父类的那个类, 第二参数可缺(返回非绑定父类对象),也可以是实例对象或该类的子类.<br />
最终返回的都是父类的实例(绑定或非绑定).<br />
在Python3中,super函数多了一种用法是直接super(),相当于super(type,首参), 这个首参就是一般的传入的self实例本身啦. 因为在py2里面常用也是这种写法.<br />
另外, 在py2中, super只支持新类( new-style class, 就是继承自object的).</p>
<p>&nbsp;</p>
<p>是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。总之前人留下的经验就是：保持一致性。要不全部用类名调用父类，要不就全部用 super，不要一半一半。<br />
<strong>普通继承</strong></p>
<blockquote><p>class FooParent(object):<br />
————def __init__(self):<br />
————————self.parent = &#8216;I\&#8217;m the parent.&#8217;<br />
————————print &#8216;Parent&#8217;<br />
————<br />
————def bar(self,message):<br />
————————print message, &#8216;from Parent&#8217;<br />
————————<br />
class FooChild(FooParent):<br />
————def __init__(self):<br />
————————FooParent.__init__(self)<br />
————————print &#8216;Child&#8217;<br />
————————<br />
————def bar(self,message):<br />
————————FooParent.bar(self,message)<br />
————————print &#8216;Child bar function.&#8217;<br />
————————print self.parent<br />
————————<br />
if __name__==&#8217;__main__&#8217;:<br />
————fooChild = FooChild()<br />
————fooChild.bar(&#8216;HelloWorld&#8217;)</p></blockquote>
<p><strong>super继承</strong></p>
<blockquote><p>class FooParent(object):<br />
————def __init__(self):<br />
————————self.parent = &#8216;I\&#8217;m the parent.&#8217;<br />
————————print &#8216;Parent&#8217;<br />
————<br />
————def bar(self,message):<br />
————————print message,&#8217;from Parent&#8217;</p>
<p>class FooChild(FooParent):<br />
————def __init__(self):<br />
————————super(FooChild,self).__init__()<br />
————————print &#8216;Child&#8217;<br />
————————<br />
————def bar(self,message):<br />
————————super(FooChild, self).bar(message)<br />
————————print &#8216;Child bar fuction&#8217;<br />
————————print self.parent</p>
<p>if __name__ == &#8216;__main__&#8217;:<br />
————fooChild = FooChild()<br />
————fooChild.bar(&#8216;HelloWorld&#8217;)</p></blockquote>
<p>程序运行结果相同，为：<br />
代码如下:<br />
Parent<br />
Child<br />
HelloWorld from Parent<br />
Child bar fuction<br />
I&#8217;m the parent.<br />
从运行结果上看，普通继承和super继承是一样的。但是其实它们的内部运行机制不一样，这一点在多重继承时体现得很明显。在super机制里可以保证公共父类仅被执行一次，至于执行的顺序，是按照mro进行的（E.__mro__）。<br />
注意super继承只能用于新式类，用于经典类时就会报错。<br />
新式类：必须有继承的类，如果没什么想继承的，那就继承object<br />
经典类：没有父类，如果此时调用super就会出现错误：『super() argument 1 must be type, not classobj』</p>
<p><strong>super(type[, object-or-type])</strong><br />
Return the superclass of type. If the second argument is omitted the super object<br />
returned is unbound. If the second argument is an object, isinstance(obj, type)<br />
must be true. If the second argument is a type, issubclass(type2, type) must be<br />
true. super() only works for new-style classes.<br />
A typical use for calling a cooperative superclass method is:<br />
class C(B):<br />
————def meth(self, arg):<br />
————————super(C, self).meth(arg)</p>
<p>我们考查的是Python 2.3的源码（估计Python 2.4的源码可能也差不多）。首先，搜索关键字&#8221;super&#8221;。唯一找到的是bltinmodule.c中的一句：<br />
SETBUILTIN(&#8220;super&#8221;, &amp;PySuper_Type);<br />
于是，我们有了对super的第一个误解：super并非是一个函数，而是一个类（PySuper_Type）。<br />
在typeobject.c中找到了PySuper_Type的定义：</p>
<blockquote><p>PyTypeObject PySuper_Type = {<br />
PyObject_HEAD_INIT(&amp;PyType_Type)<br />
0, /* ob_size */<br />
&#8220;super&#8221;, /* tp_name */<br />
sizeof(superobject), /* tp_basicsize */<br />
0, /* tp_itemsize */<br />
/* methods */<br />
super_dealloc, /* tp_dealloc */<br />
0, /* tp_print */<br />
0, /* tp_getattr */<br />
0, /* tp_setattr */<br />
0, /* tp_compare */<br />
super_repr, /* tp_repr */<br />
0, /* tp_as_number */<br />
0, /* tp_as_sequence */<br />
0, /* tp_as_mapping */<br />
0, /* tp_hash */<br />
0, /* tp_call */<br />
0, /* tp_str */<br />
super_getattro, /* tp_getattro */<br />
0, /* tp_setattro */<br />
0, /* tp_as_buffer */<br />
Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |<br />
Py_TPFLAGS_BASETYPE, /* tp_flags */<br />
super_doc, /* tp_doc */<br />
super_traverse, /* tp_traverse */<br />
0, /* tp_clear */<br />
0, /* tp_richcompare */<br />
0, /* tp_weaklistoffset */<br />
0, /* tp_iter */<br />
0, /* tp_iternext */<br />
0, /* tp_methods */<br />
super_members, /* tp_members */<br />
0, /* tp_getset */<br />
0, /* tp_base */<br />
0, /* tp_dict */<br />
super_descr_get, /* tp_descr_get */<br />
0, /* tp_descr_set */<br />
0, /* tp_dictoffset */<br />
super_init, /* tp_init */<br />
PyType_GenericAlloc, /* tp_alloc */<br />
PyType_GenericNew, /* tp_new */<br />
PyObject_GC_Del, /* tp_free */<br />
};</p></blockquote>
<p>从代码中可以得知，<br />
super类只改写了几个方法，最主要的包括：tp_dealloc，tp_getattro，tp_traverse，tp_init。<br />
再看superobject的定义：<br />
代码段6：<br />
typedef struct {<br />
PyObject_HEAD<br />
PyTypeObject *type;<br />
PyObject *obj;<br />
PyTypeObject *obj_type;<br />
} superobject;</p>
<p>从代码段6中可以看到superobject的数据成员仅有3个指针（3个对象的引用）。要知道这3个对象分别代表什么，则必需考查super_init的定义：<br />
代码段7：</p>
<blockquote><p>static int<br />
super_init(PyObject *self, PyObject *args, PyObject *kwds)<br />
{<br />
superobject *su = (superobject *)self;<br />
PyTypeObject *type;<br />
PyObject *obj = NULL;<br />
PyTypeObject *obj_type = NULL;</p>
<p>if (!PyArg_ParseTuple(args, &#8220;O!|O:super&#8221;, &amp;PyType_Type, &amp;type, &amp;obj))<br />
return -1;<br />
if (obj == Py_None)<br />
obj = NULL;<br />
if (obj != NULL) {<br />
obj_type = supercheck(type, obj);<br />
if (obj_type == NULL)<br />
return -1;<br />
Py_INCREF(obj);<br />
}<br />
Py_INCREF(type);<br />
su-&gt;type = type;<br />
su-&gt;obj = obj;<br />
su-&gt;obj_type = obj_type;<br />
return 0;<br />
}</p></blockquote>
<p>从代码中可以看到，super_init首先通过PyArg_ParseTuple把传入的参数列表解释出来，分别放在type和obj变量之中。然后通过supercheck测试可选参数obj是否合法，并获得实例obj的具体类类型。最后，把type, obj和obj_type记录下来。也就是说，super对象只是简单作了一些记录，并没有作任何转换操作。</p>
<p>查找问题的切入点是为什么在类C中的super调用会切换到类D的初始化函数。于是在super_init中添加条件断点，并跟踪其后的Python代码。最终进入到super_getattro函数——对应于super对象访问名字__init__时的搜索操作。<br />
代码段8（省略部分无关代码，并加入一些注释）：</p>
<blockquote><p>static PyObject *<br />
super_getattro(PyObject *self, PyObject *name)<br />
{<br />
superobject *su = (superobject *)self;<br />
int skip = su-&gt;obj_type == NULL;<br />
……<br />
if (!skip) {<br />
PyObject *mro, *res, *tmp, *dict;<br />
PyTypeObject *starttype;<br />
descrgetfunc f;<br />
int i, n;<br />
starttype = su-&gt;obj_type; // 获得搜索的起点：super对象的obj_type<br />
mro = starttype-&gt;tp_mro; // 获得类的mro<br />
……<br />
for (i = 0; i &lt; n; i++) { // 搜索mro中，定位mro中的type if ((PyObject *)(su-&gt;type) == PyTuple_GET_ITEM(mro, i))<br />
break;<br />
}<br />
i++; // 切换到mro中的下一个类<br />
res = NULL;<br />
for (; i &lt; n; i++) { // 在mro以后的各个命名空间中搜索指定名字 tmp = PyTuple_GET_ITEM(mro, i); if (PyType_Check(tmp)) dict = ((PyTypeObject *)tmp)-&gt;tp_dict;<br />
else if (PyClass_Check(tmp))<br />
dict = ((PyClassObject *)tmp)-&gt;cl_dict;<br />
else<br />
continue;<br />
res = PyDict_GetItem(dict, name);<br />
if (res != NULL) {<br />
Py_INCREF(res);<br />
f = res-&gt;ob_type-&gt;tp_descr_get;<br />
if (f != NULL) {<br />
tmp = f(res, su-&gt;obj,<br />
(PyObject *)starttype);<br />
Py_DECREF(res);<br />
res = tmp;<br />
}<br />
return res;<br />
}<br />
}<br />
}<br />
return PyObject_GenericGetAttr(self, name);<br />
}</p></blockquote>
<p>从代码中可以看出，super对象在搜索命名空间时，其实是基于类实例的mro进行。那么什么是mro呢？查找官方文档，有：<br />
PyObject* tp_mro<br />
Tuple containing the expanded set of base types, starting with the type itself and<br />
ending with object, in Method Resolution Order.<br />
This field is not inherited; it is calculated fresh by PyType_Ready().</p>
<p>也就是说，mro中记录了一个类的所有基类的类类型序列。查看mro的记录，发觉包含7个元素，7个类名分别为：<br />
F E B C D A object</p>
<p>从而说明了为什么在C.__init__中使用super(C, self).__init__()会调用类D的初始化函数了<br />
代码段9：</p>
<blockquote><p>class A(object):<br />
&#8212;def __init__(self):<br />
&#8212;&#8212;print &#8220;enter A&#8221;<br />
&#8212;&#8212;super(A, self).__init__() # new<br />
&#8212;&#8212;print &#8220;leave A&#8221;<br />
class B(object):<br />
&#8212;def __init__(self):<br />
&#8212;&#8212;print &#8220;enter B&#8221;<br />
&#8212;&#8212;super(B, self).__init__() # new<br />
&#8212;&#8212;print &#8220;leave B&#8221;<br />
class C(A):<br />
&#8212;def __init__(self):<br />
&#8212;&#8212;print &#8220;enter C&#8221;<br />
&#8212;&#8212;super(C, self).__init__()<br />
&#8212;&#8212;print &#8220;leave C&#8221;<br />
class D(A):<br />
&#8212;def __init__(self):<br />
&#8212;&#8212;print &#8220;enter D&#8221;<br />
&#8212;&#8212;super(D, self).__init__()<br />
&#8212;&#8212;print &#8220;leave D&#8221;<br />
class E(B, C):<br />
&#8212;def __init__(self):<br />
&#8212;&#8212;print &#8220;enter E&#8221;<br />
&#8212;&#8212;super(E, self).__init__() # change<br />
&#8212;&#8212;print &#8220;leave E&#8221;<br />
class F(E, D):<br />
&#8212;def __init__(self):<br />
&#8212;&#8212;print &#8220;enter F&#8221;<br />
&#8212;&#8212;super(F, self).__init__() # change<br />
&#8212;&#8212;print &#8220;leave F&#8221;<br />
f = F()</p></blockquote>
<p>enter F<br />
enter E<br />
enter B<br />
enter C<br />
enter D<br />
enter A<br />
leave A<br />
leave D<br />
leave C<br />
leave B<br />
leave E<br />
leave F</p>
<p>明显地，F的初始化不仅完成了所有的父类的调用，而且保证了每一个父类的初始化函数只调用一次。</p>
<p><strong>三、延续的讨论</strong><br />
我们再重新看上面的类体系图，如果把每一个类看作图的一个节点，每一个从子类到父类的直接继承关系看作一条有向边，那么该体系图将变为一个有向图。不能发现mro的顺序正好是该有向图的一个拓扑排序序列。<br />
从而，我们得到了另一个结果——Python是如何去处理多继承。支持多继承的传统的面向对象程序语言（如C++）是通过虚拟继承的方式去实现多继承中父类的构造函数被多次调用的问题，而Python则通过mro的方式去处理。<br />
但这给我们一个难题：对于提供类体系的编写者来说，他不知道使用者会怎么使用他的类体系，也就是说，不正确的后续类，可能会导致原有类体系的错误，而且这样的错误非常隐蔽的，也难于发现。<br />
<strong>四、小结</strong><br />
1. super并不是一个函数，是一个类名，形如super(B, self)事实上调用了super类的初始化函数，<br />
产生了一个super对象；<br />
2. super类的初始化函数并没有做什么特殊的操作，只是简单记录了类类型和具体实例；<br />
3. super(B, self).func的调用并不是用于调用当前类的父类的func函数；<br />
4. Python的多继承类是通过mro的方式来保证各个父类的函数被逐一调用，而且保证每个父类函数<br />
只调用一次（如果每个类都使用super）；<br />
5. 混用super类和非绑定的函数是一个危险行为，这可能导致应该调用的父类函数没有调用或者一<br />
个父类函数被调用多次。</p>
<p><strong>tips</strong><br />
从super()方法可以看出，super（）的第一个参数可以是继承链中任意一个类的名字，<br />
如果是本身就会依次继承下一个类；<br />
如果是继承链里之前的类便会无限递归下去；<br />
如果是继承链里之后的类便会忽略继承链汇总本身和传入类之间的类；<br />
比如将childA()中的super改为：super(childC, self).__init__()，程序就会无限递归下去</p>
<p>mro()用来获得类的继承顺序。</p>
<p>class Base(object):<br />
&#8212;-def __init__(self):<br />
&#8212;&#8212;&#8211;print &#8216;Base create&#8217;</p>
<p>class childA(Base):<br />
&#8212;-def __init__(self):<br />
&#8212;&#8212;&#8211;print &#8216;enter A &#8216;<br />
&#8212;&#8212;&#8211;# Base.__init__(self)<br />
&#8212;&#8212;&#8211;super(childA, self).__init__()<br />
&#8212;&#8212;&#8211;print &#8216;leave A&#8217;</p>
<p>class childB(Base):<br />
&#8212;-def __init__(self):<br />
&#8212;&#8212;&#8211;print &#8216;enter B &#8216;<br />
&#8212;&#8212;&#8211;# Base.__init__(self)<br />
&#8212;&#8212;&#8211;super(childB, self).__init__()<br />
&#8212;&#8212;&#8211;print &#8216;leave B&#8217;</p>
<p>class childC(childA, childB):<br />
&#8212;-pass</p>
<p>c = childC()<br />
print c.__class__.__mro__</p>
<p>supder和父类没有关联，因此执行顺序是A —&gt; B—&gt;—&gt;Base<br />
执行过程相当于：初始化childC()时，先会去调用childA的构造方法中的 super(childA, self).__init__()， super(childA, self)返回当前类的继承顺序中childA后的一个类childB；然后再执行childB().__init()__,这样顺序执行下去。<br />
在多重继承里，如果把childA()中的 super(childA, self).__init__() 换成Base.__init__(self)，在执行时，继承childA后就会直接跳到Base类里，而略过了childB：</p>
            </div>
        </div>
        <!-- 文章内容结束 -->
    </article>


</main><!-- .content-area -->

<div class="footer">
    <div class="container">

<div class="has-text-centered">
Copyright©2015-20178 cn-blogs.cn. All Rights Reserved. 鲁ICP备18001334号-2
</div>
    </div>
  </div>

</body>
</html>
