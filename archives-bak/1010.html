
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>with 异常处理 | 青春部落    </title>
    <meta name="keywords"  content="" />
    <meta name="description"  content="" />
    <link rel="stylesheet" type="text/css" media="all" href="https://cn-blogs.cn/wp-content/themes/pencilone/style.css" />
    <link rel="profile" href="http://gmpg.org/xfn/11">
    <link rel="pingback" href="https://cn-blogs.cn/xmlrpc.php">
    <link id="favicon" href="/favicon.ico" rel="icon" type="image/x-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="青春部落 &raquo; with 异常处理评论Feed" href="https://cn-blogs.cn/archives/1010.html/feed" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/cn-blogs.cn\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.9.1"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55358,56794,8205,9794,65039],[55358,56794,8203,9794,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='https://api.w.org/' href='https://cn-blogs.cn/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://cn-blogs.cn/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://cn-blogs.cn/wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='Lambda 匿名函数' href='https://cn-blogs.cn/archives/1007.html' />
<link rel='next' title='Python编程SQLite数据库：连接类\游标类\execute方法' href='https://cn-blogs.cn/archives/1017.html' />
<meta name="generator" content="WordPress 4.9.1" />
<link rel="canonical" href="https://cn-blogs.cn/archives/1010.html" />
<link rel='shortlink' href='https://cn-blogs.cn/?p=1010' />
<link rel="alternate" type="application/json+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F1010.html" />
<link rel="alternate" type="text/xml+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F1010.html&#038;format=xml" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-32x32.png" sizes="32x32" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-180x180.png" />
<meta name="msapplication-TileImage" content="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-270x270.png" />

<meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">


</head>

<body class="post-template-default single single-post postid-1010 single-format-standard">
<header class="navbar">
<div class="container">
    <div class="navbar-brand">
        <img src="/logo.png" width="73" height="88">
        <div>
        <h1 class="title2 is-3 navbar-item">
            <a href="https://cn-blogs.cn/" rel="home">青春部落</a>
        </h1>
        <p class="has-text-right">
            <a href="/">记录生活的足迹</a>
        </p>
        </div>
    </div>
    <div class="navbar-menu is-active">
    <div class="navbar-end">
    <div class="tabs is-right">
    <a class="navbar-item" href="/pages/index.html">索引</a>
    <a class="navbar-item" href="/about">About</a>
    </div>
    </div>
    </div>
</div>
</header>


<main class="container">
        <article class="article margin-top20">

        <!-- 文章分类和上一篇\下一篇 -->
        <div class="box columns">
            <!-- 文章分类 -->
            <div class="column is-two-fifth">
                <div class="categproe-name">分类：</div>
                <ul class="post-categories">
	<li><a href="https://cn-blogs.cn/archives/category/development/python" rel="category tag">Python</a></li></ul>            </div>
            <!-- 文章分类结束 -->

            <!-- 上一篇和下一篇 -->
            <div class="column is-two-fifth is-offset-5">
                
	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">Post navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://cn-blogs.cn/archives/1007.html" rel="prev">上一篇：Lambda 匿名函数</a></div><div class="nav-next"><a href="https://cn-blogs.cn/archives/1017.html" rel="next">下一篇：Python编程SQLite数据库：连接类\游标类\execute方法</a></div></div>
	</nav>            </div>
            <!-- 上一篇和下一篇结束 -->
        </div>

        <!-- 文章信息 -->
        <!-- 文章标题 -->
        <div class="title is-3 has-text-centered">
            with 异常处理        </div>
        <!-- 文章标题结束 -->

        <!-- 文章作者、发布时间、更新时间 -->
        <div class="subtitle is-5 has-text-centered">
            <span class="entry-author"><a href="https://cn-blogs.cn/archives/author/admin" title="由admin发布" rel="author">admin</a></span>
            <span class="entry-date">2016/11/10</span>
            <span class="update is-hidden">2016-11-10</span>
        </div>
        <!-- 文章作者、发布时间、更新时间结束 -->

        <!-- 文章内容 -->
        <div class="content article-body">
            <div class="content">
                <p>with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 from __future__ import with_statement 导入后才可以使用），从 2.6 版本开始缺省可用（参考 What&#8217;s new in Python 2.6? 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<p><strong>术语</strong><br />
要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。<br />
下面是一组与上下文管理器和with 语句有关的概念。<br />
<strong>上下文管理协议（Context Management Protocol）</strong>：包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。</p>
<p><strong>上下文管理器（Context Manager）</strong>：支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p><strong>运行时上下文（runtime context）：</strong>由上下文管理器创建，通过上下文管理器的__enter__() 和__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p>
<p><strong>上下文表达式（Context Expression）</strong>：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。</p>
<p><strong>语句体（with-body）</strong>：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 __enter__() 方法，执行完语句体之后会执行 __exit__() 方法。</p>
<p><strong>基本语法和工作原理</strong><br />
with 语句的语法格式如下：<br />
1. with 语句的语法格式<br />
————with context_expression [as target(s)]:<br />
————————with-body<br />
这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 __enter__() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。<br />
Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：<br />
2. 使用 with 语句操作文件对象<br />
————with open(r&#8217;somefileName&#8217;) as somefile:<br />
————————for line in somefile:<br />
————————————print line<br />
————————————# &#8230;more code<br />
这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：<br />
3. try/finally 方式操作文件对象<br />
————somefile = open(r&#8217;somefileName&#8217;)<br />
————try:<br />
————————for line in somefile:<br />
————————————print line<br />
————————————# &#8230;more code<br />
————finally:<br />
————————somefile.close()<br />
比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。<br />
PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：<br />
4. with 语句执行过程<br />
————context_manager = context_expression<br />
————exit = type(context_manager).__exit__<br />
————value = type(context_manager).__enter__(context_manager)<br />
————exc = True # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理<br />
————try:<br />
————————try:<br />
————————————target = value # 如果使用了 as 子句<br />
————————————with-body———— # 执行 with-body<br />
————————except:<br />
————————————# 执行过程中有异常发生<br />
————————————exc = False<br />
————————————# 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常<br />
————————————# 由外层代码对异常进行处理<br />
————————————if not exit(context_manager, *sys.exc_info()):<br />
————————————————raise<br />
————finally:<br />
————————# 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出<br />
————————# 或者忽略异常退出<br />
————————if exc:<br />
————————————exit(context_manager, None, None, None)<br />
————————# 缺省返回 None，None 在布尔上下文中看做是 False<br />
执行 context_expression，生成上下文管理器 context_manager<br />
调用上下文管理器的 __enter__() 方法；如果使用了 as 子句，则将 __enter__() 方法的返回值赋值给 as 子句中的 target(s)<br />
执行语句体 with-body<br />
不管是否执行过程中是否发生了异常，执行上下文管理器的 __exit__() 方法，__exit__() 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 __exit__(None, None, None) ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 __exit__(exc_type, exc_value, exc_traceback)<br />
出现异常时，如果 __exit__(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</p>
<h2><strong>自定义上下文管理器</strong></h2>
<p>开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的 __enter__() 和 __exit__() 两个方法：<br />
<strong>context_manager.__enter__() ：</strong>进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话<br />
<strong>context_manager.__exit__(exc_type, exc_value, exc_traceback) ：</strong>退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常，返回<br />
True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由 statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为 False 就可以了。之后，上下文管理代码会检测是否 __exit__() 失败来处理异常<br />
下面通过一个简单的示例来演示如何构建自定义的上下文管理器。注意，上下文管理器必须同时提供 __enter__() 和 __exit__() 方法的定义，缺少任何一个都会导致 AttributeError；with 语句会先检查是否提供了 __exit__() 方法，然后检查是否定义了 __enter__() 方法。<br />
假设有一个资源 DummyResource，这种资源需要在访问前先分配，使用完后再释放掉；分配操作可以放到 __enter__() 方法中，释放操作可以放到 __exit__() 方法中。简单起见，这里只通过打印语句来表明当前的操作，并没有实际的资源分配与释放。<br />
5. 自定义支持 with 语句的对象<br />
————class DummyResource:<br />
————def __init__(self, tag):<br />
————————————self.tag = tag<br />
————————————print &#8216;Resource [%s]&#8217; % tag<br />
————————def __enter__(self):<br />
————————————print &#8216;[Enter %s]: Allocate resource.&#8217; % self.tag<br />
————————————return self # 可以返回不同的对象<br />
————————def __exit__(self, exc_type, exc_value, exc_tb):<br />
————————————print &#8216;[Exit %s]: Free resource.&#8217; % self.tag<br />
————————————if exc_tb is None:<br />
————————————————print &#8216;[Exit %s]: Exited without exception.&#8217; % self.tag<br />
————————————else:<br />
————————————————print &#8216;[Exit %s]: Exited with exception raised.&#8217; % self.tag<br />
————————————————return False # 可以省略，缺省的None也是被看做是False<br />
DummyResource 中的 __enter__() 返回的是自身的引用，这个引用可以赋值给 as 子句中的 target 变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。<br />
__exit__() 方法中对变量 exc_tb 进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生，__exit__() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。<br />
下面在 with 语句中访问 DummyResource ：<br />
6. 使用自定义的支持 with 语句的对象<br />
————with DummyResource(&#8216;Normal&#8217;):<br />
————————print &#8216;[with-body] Run without exceptions.&#8217;</p>
<p>————with DummyResource(&#8216;With-Exception&#8217;):<br />
————————print &#8216;[with-body] Run with exception.&#8217;<br />
————————raise Exception<br />
————————print &#8216;[with-body] Run with exception. Failed to finish statement-body!&#8217;<br />
第1个 with 语句的执行结果如下：<br />
7. with 语句1执行结果<br />
————Resource [Normal]<br />
————[Enter Normal]: Allocate resource.<br />
————[with-body] Run without exceptions.<br />
————[Exit Normal]: Free resource.<br />
————[Exit Normal]: Exited without exception.<br />
可以看到，正常执行时会先执行完语句体 with-body，然后执行 __exit__() 方法释放资源。<br />
第2个 with 语句的执行结果如下：<br />
8. with 语句2执行结果<br />
————Resource [With-Exception]<br />
————[Enter With-Exception]: Allocate resource.<br />
————[with-body] Run with exception.<br />
————[Exit With-Exception]: Free resource.<br />
————[Exit With-Exception]: Exited with exception raised.</p>
<p>————Traceback (most recent call last):<br />
———— File &#8220;G:/demo&#8221;, line 20, in<br />
———— raise Exception<br />
————Exception<br />
可以看到，with-body 中发生异常时with-body 并没有执行完，但资源会保证被释放掉，同时产生的异常由 with 语句之外的代码逻辑来捕获处理。<br />
可以自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。Python 在线文档 Writing Context Managers 提供了一个针对数据库连接进行管理的上下文管理器的简单范例。</p>
<h2><strong>contextlib 模块</strong></h2>
<p>contextlib 模块提供了3个对象：装饰器 contextmanager、函数 nested 和上下文管理器 closing。使用这些对象，可以对已有的生成器函数或者对象进行包装，加入对上下文管理协议的支持，避免了专门编写上下文管理器来支持 with 语句。<br />
<strong>装饰器 contextmanager</strong><br />
contextmanager 用于对生成器函数进行装饰，生成器函数被装饰以后，返回的是一个上下文管理器，其 __enter__() 和 __exit__() 方法由 contextmanager 负责提供，而不再是之前的迭代子。被装饰的生成器函数只能产生一个值，否则会导致异常 RuntimeError；产生的值会赋值给 as 子句中的 target，如果使用了 as 子句的话。下面看一个简单的例子。<br />
9. 装饰器 contextmanager 使用示例<br />
————from contextlib import contextmanager</p>
<p>————@contextmanager<br />
————def demo():<br />
————————print &#8216;[Allocate resources]&#8217;<br />
————————print &#8216;Code before yield-statement executes in __enter__&#8217;<br />
————————yield &#8216;*** contextmanager demo ***&#8217;<br />
————————print &#8216;Code after yield-statement executes in __exit__&#8217;<br />
————————print &#8216;[Free resources]&#8217;</p>
<p>————with demo() as value:<br />
————————print &#8216;Assigned Value: %s&#8217; % value<br />
结果输出如下：<br />
10. contextmanager 使用示例执行结果<br />
————[Allocate resources]<br />
————Code before yield-statement executes in __enter__<br />
————Assigned Value: *** contextmanager demo ***<br />
————Code after yield-statement executes in __exit__<br />
————[Free resources]<br />
可以看到，生成器函数中 yield 之前的语句在 __enter__() 方法中执行，yield 之后的语句在 __exit__() 中执行，而 yield 产生的值赋给了 as 子句中的 value 变量。<br />
需要注意的是，contextmanager 只是省略了 __enter__() / __exit__() 的编写，但并不负责实现资源的“获取”和“清理”工作；“获取”操作需要定义在 yield 语句之前，“清理”操作需要定义 yield 语句之后，这样 with 语句在执行 __enter__() / __exit__() 方法时会执行这些语句以获取/释放资源，即生成器函数中需要实现必要的逻辑控制，包括资源访问出现错误时抛出适当的异常。<br />
<strong>函数 nested</strong><br />
nested 可以将多个上下文管理器组织在一起，避免使用嵌套 with 语句。<br />
11. nested 语法<br />
————with nested(A(), B(), C()) as (X, Y, Z):<br />
———————— # with-body code here<br />
类似于：<br />
12. nested 执行过程<br />
————with A() as X:<br />
————————with B() as Y:<br />
————————————with C() as Z:<br />
———————————————— # with-body code here<br />
需要注意的是，发生异常后，如果某个上下文管理器的 __exit__() 方法对异常处理返回 False，则更外层的上下文管理器不会监测到异常。<br />
<strong>上下文管理器 closing</strong><br />
closing 的实现如下：<br />
13. 上下文管理 closing 实现<br />
————class closing(object):<br />
————————# help doc here<br />
————————def __init__(self, thing):<br />
————————————self.thing = thing<br />
————————def __enter__(self):<br />
————————————return self.thing<br />
————————def __exit__(self, *exc_info):<br />
————————————self.thing.close()<br />
上下文管理器会将包装的对象赋值给 as 子句的 target 变量，同时保证打开的对象在 with-body 执行完后会关闭掉。closing 上下文管理器包装起来的对象必须提供 close() 方法的定义，否则执行时会报 AttributeError 错误。<br />
14. 自定义支持 closing 的对象<br />
————class ClosingDemo(object):<br />
————————def __init__(self):<br />
————————————self.acquire()<br />
————————def acquire(self):<br />
————————————print &#8216;Acquire resources.&#8217;<br />
————————def free(self):<br />
————————————print &#8216;Clean up any resources acquired.&#8217;<br />
————————def close(self):<br />
————————————self.free()</p>
<p>————with closing(ClosingDemo()):<br />
————————print &#8216;Using resources&#8217;<br />
结果输出如下：<br />
15. 自定义 closing 对象的输出结果<br />
————Acquire resources.<br />
————Using resources<br />
————Clean up any resources acquired.<br />
closing 适用于提供了 close() 实现的对象，比如网络连接、数据库连接等，也可以在自定义类时通过接口 close() 来执行所需要的资源“清理”工作。</p>
<p><strong>小结</strong><br />
本文对 with 语句的语法和工作机理进行了介绍，并通过示例介绍了如何实现自定义的上下文管理器，最后介绍了如何使用 contextlib 模块来简化上下文管理器的编写。</p>
            </div>
        </div>
        <!-- 文章内容结束 -->
    </article>


</main><!-- .content-area -->

<div class="footer">
    <div class="container">

<div class="has-text-centered">
Copyright©2015-20178 cn-blogs.cn. All Rights Reserved. 鲁ICP备18001334号-2
</div>
    </div>
  </div>

</body>
</html>
