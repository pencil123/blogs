
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>操作系统的I/O过程 | 青春部落    </title>
    <meta name="keywords"  content="系统IO操作,select,poll,epoll,阻塞,非阻塞,异步,多路复用" />
    <meta name="description"  content="操作系统中的I/O过程分为阻塞I/O\非阻塞I/O\多路复用I/O\异步I/O" />
    <link rel="stylesheet" type="text/css" media="all" href="https://cn-blogs.cn/wp-content/themes/pencilone/style.css" />
    <link rel="profile" href="http://gmpg.org/xfn/11">
    <link rel="pingback" href="https://cn-blogs.cn/xmlrpc.php">
    <link id="favicon" href="/favicon.ico" rel="icon" type="image/x-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="青春部落 &raquo; 操作系统的I/O过程评论Feed" href="https://cn-blogs.cn/archives/1105.html/feed" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/cn-blogs.cn\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.9.1"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55358,56794,8205,9794,65039],[55358,56794,8203,9794,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='https://api.w.org/' href='https://cn-blogs.cn/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://cn-blogs.cn/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://cn-blogs.cn/wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='Git 远程仓库和远程分支' href='https://cn-blogs.cn/archives/2811.html' />
<link rel='next' title='非阻塞和异步' href='https://cn-blogs.cn/archives/1123.html' />
<meta name="generator" content="WordPress 4.9.1" />
<link rel="canonical" href="https://cn-blogs.cn/archives/1105.html" />
<link rel='shortlink' href='https://cn-blogs.cn/?p=1105' />
<link rel="alternate" type="application/json+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F1105.html" />
<link rel="alternate" type="text/xml+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F1105.html&#038;format=xml" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-32x32.png" sizes="32x32" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-180x180.png" />
<meta name="msapplication-TileImage" content="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-270x270.png" />

<meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">


</head>

<body class="post-template-default single single-post postid-1105 single-format-standard">
<header class="navbar">
<div class="container">
    <div class="navbar-brand">
        <img src="/logo.png" width="73" height="88">
        <div>
        <h1 class="title2 is-3 navbar-item">
            <a href="https://cn-blogs.cn/" rel="home">青春部落</a>
        </h1>
        <p class="has-text-right">
            <a href="/">记录生活的足迹</a>
        </p>
        </div>
    </div>
    <div class="navbar-menu is-active">
    <div class="navbar-end">
    <div class="tabs is-right">
    <a class="navbar-item" href="/pages/index.html">索引</a>
    <a class="navbar-item" href="/about">About</a>
    </div>
    </div>
    </div>
</div>
</header>


<main class="container">
        <article class="article margin-top20">

        <!-- 文章分类和上一篇\下一篇 -->
        <div class="box columns">
            <!-- 文章分类 -->
            <div class="column is-two-fifth">
                <div class="categproe-name">分类：</div>
                <ul class="post-categories">
	<li><a href="https://cn-blogs.cn/archives/category/kernel/hard-system" rel="category tag">内核&amp;硬件系统</a></li></ul>            </div>
            <!-- 文章分类结束 -->

            <!-- 上一篇和下一篇 -->
            <div class="column is-two-fifth is-offset-5">
                
	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">Post navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://cn-blogs.cn/archives/2811.html" rel="prev">上一篇：Git 远程仓库和远程分支</a></div><div class="nav-next"><a href="https://cn-blogs.cn/archives/1123.html" rel="next">下一篇：非阻塞和异步</a></div></div>
	</nav>            </div>
            <!-- 上一篇和下一篇结束 -->
        </div>

        <!-- 文章信息 -->
        <!-- 文章标题 -->
        <div class="title is-3 has-text-centered">
            操作系统的I/O过程        </div>
        <!-- 文章标题结束 -->

        <!-- 文章作者、发布时间、更新时间 -->
        <div class="subtitle is-5 has-text-centered">
            <span class="entry-author"><a href="https://cn-blogs.cn/archives/author/admin" title="由admin发布" rel="author">admin</a></span>
            <span class="entry-date">2017/01/03</span>
            <span class="update is-hidden">2018-06-02</span>
        </div>
        <!-- 文章作者、发布时间、更新时间结束 -->

        <!-- 文章内容 -->
        <div class="content article-body">
            <div class="content">
                <h2>概述</h2>
<p>本文内容主要来自网络，来探讨一下操作系统的I/O过程。以Linux系统的网络数据传输的I/O过程为例。</p>
<h2>引子</h2>
<p>在学习操作系统I/O过程之前，需要有一些知识储备。要明白I/O过程在操作系统中的意义和位置；在考虑I/O问题时，需要注意哪些细节。</p>
<h4>用户空间与内核空间</h4>
<p>现在操作系统都是采用虚拟存储器，即对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<br />
操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。<br />
针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h4>进程切换</h4>
<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。<br />
因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。<br />
<strong>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</strong><br />
1. 保存处理机上下文，包括程序计数器和其他寄存器。<br />
2. 更新PCB信息。<br />
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br />
4. 选择另一个进程执行，并更新其PCB。<br />
5. 更新内存管理的数据结构。<br />
6. 恢复处理机上下文。</p>
<h4>进程的阻塞</h4>
<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。<br />
可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p>
<h4>文件描述符fd</h4>
<p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br />
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h3>缓存和缓冲</h3>
<p>所有I/O的操作，都会涉及到Cache和Buffer的优化。</p>
<h4>I/O的缓存</h4>
<p>缓存cache 根据数据的局部性等策略，将数据预先加载。<br />
缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。<br />
缓存Cache 数据在存储介质间交互的过程中；为了弥补低速设备（硬盘）对高速设备（内存）的拖后腿情况；利用数据的局部性特征，在两者之间建立一个中间层，将相关的数据写入到中间层；从而提高了高速设备获取数据的速度。<br />
<strong>缓存 I/O 的缺点</strong><br />
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h4>I/O的缓冲</h4>
<p>buffer 将“小数据，多数量”的操作，整合为“大数据，小数量”的操作。比如邮局整理邮件，批次发送。<br />
buffer 进行流量整型；把突发的大数量较小规模的I/O整理成平稳的小数量较大规模的I/O。减少数据的写入次数，保护硬盘。</p>
<h2>IO模式</h2>
<p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。<br />
所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ul>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ul>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p><strong>注：</strong>由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>
<h4>阻塞 I/O（blocking IO）</h4>
<p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br />
<a href="http://www.cn-blogs.cn/wp-content/uploads/2017/01/1.png"><img class="alignnone size-full wp-image-1109" src="http://www.cn-blogs.cn/wp-content/uploads/2017/01/1.png" alt="blocking" width="552" height="331" srcset="https://cn-blogs.cn/wp-content/uploads/2017/01/1.png 552w, https://cn-blogs.cn/wp-content/uploads/2017/01/1-300x180.png 300w" sizes="(max-width: 552px) 100vw, 552px" /></a><br />
当用户进程调用了recvfrom这个系统调用，I/O操作就开始了。<br />
<strong>第一个阶段</strong>：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。<br />
<strong>第二个阶段</strong>：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br />
所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<h4>非阻塞 I/O（nonblocking IO）</h4>
<p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br />
<a href="http://www.cn-blogs.cn/wp-content/uploads/2017/01/2.png"><img class="alignnone size-full wp-image-1110" src="http://www.cn-blogs.cn/wp-content/uploads/2017/01/2.png" alt="nonblocking" width="603" height="333" srcset="https://cn-blogs.cn/wp-content/uploads/2017/01/2.png 603w, https://cn-blogs.cn/wp-content/uploads/2017/01/2-300x166.png 300w" sizes="(max-width: 603px) 100vw, 603px" /></a><br />
当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。<br />
用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br />
所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
<h4>I/O 多路复用（ IO multiplexing）</h4>
<p>IO multiplexing就是我们说的Select，Poll，Epoll；有些地方也称这种IO方式为event driven IO。Select/Epoll的好处就在于单个process就可以同时处理多个网络连接的IO。<br />
它的基本原理就是Select，Poll，Epoll这个function会不断的轮询所负责的所有Socket，当某个Socket有数据到达了，就通知用户进程。<br />
<a href="http://www.cn-blogs.cn/wp-content/uploads/2017/01/3.png"><img class="alignnone size-full wp-image-1111" src="http://www.cn-blogs.cn/wp-content/uploads/2017/01/3.png" alt="multiplex" width="609" height="326" srcset="https://cn-blogs.cn/wp-content/uploads/2017/01/3.png 609w, https://cn-blogs.cn/wp-content/uploads/2017/01/3-300x161.png 300w" sizes="(max-width: 609px) 100vw, 609px" /></a><br />
当用户进程调用了Select，那么整个进程会被Block，而同时，kernel会“监视”所有Select负责的Socket，当任何一个Socket中的数据准备好了，Select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，Select()函数就可以返回。<br />
这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。<br />
因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用Select/Epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。Select/Epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个Socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h4>异步 I/O（asynchronous IO）</h4>
<p>Linux下的asynchronous IO其实用得很少。先看一下它的流程：<br />
<a href="http://www.cn-blogs.cn/wp-content/uploads/2017/01/4.png"><img class="alignnone size-full wp-image-1112" src="http://www.cn-blogs.cn/wp-content/uploads/2017/01/4.png" alt="asynchronous" width="572" height="324" srcset="https://cn-blogs.cn/wp-content/uploads/2017/01/4.png 572w, https://cn-blogs.cn/wp-content/uploads/2017/01/4-300x170.png 300w" sizes="(max-width: 572px) 100vw, 572px" /></a><br />
用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h3>总结</h3>
<h4>blocking和non-blocking的区别</h4>
<p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h4>synchronous IO和asynchronous IO的区别</h4>
<p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br />
<code>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br />
- An asynchronous I/O operation does not cause the requesting process to be blocked;</code><br />
两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<h4>各个IO Model的比较</h4>
<p><a href="http://www.cn-blogs.cn/wp-content/uploads/2017/01/5.png"><img class="alignnone size-full wp-image-1113" src="http://www.cn-blogs.cn/wp-content/uploads/2017/01/5.png" alt="iomodel" width="614" height="327" srcset="https://cn-blogs.cn/wp-content/uploads/2017/01/5.png 614w, https://cn-blogs.cn/wp-content/uploads/2017/01/5-300x160.png 300w" sizes="(max-width: 614px) 100vw, 614px" /></a><br />
通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。<br />
在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。<br />
而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h2>I/O 多路复用</h2>
<p>select，poll，epoll都是IO多路复用的机制。<br />
I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<br />
但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h4>select</h4>
<p><code>int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br />
select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<br />
select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>
<h4>poll</h4>
<p><code>int poll (struct pollfd *fds, unsigned int nfds, int timeout);</code><br />
不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。<br />
<code>struct pollfd {<br />
~~~~int fd; /* file descriptor */<br />
~~~~short events; /* requested events to watch */<br />
~~~~short revents; /* returned events witnessed */<br />
};</code><br />
pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h3>Epoll</h3>
<p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。<br />
相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<h4>1、Epoll操作过程</h4>
<p>epoll操作过程需要三个接口，分别如下：<br />
<code>int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大<br />
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br />
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br />
<strong>1. 创建一个epoll的句柄</strong><br />
<code>int epoll_create(int size);</code><br />
size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br />
当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p><strong>2. 对指定描述符fd执行op操作</strong><br />
<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</code><br />
&#8211; epfd：是epoll_create()的返回值。<br />
&#8211; op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<br />
&#8211; fd：是需要监听的fd（文件描述符）<br />
&#8211; epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：<br />
<code>struct epoll_event {<br />
__uint32_t events; /* Epoll events */<br />
epoll_data_t data; /* User data variable */<br />
};</code><br />
//events可以是以下几个宏的集合：<br />
EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br />
EPOLLOUT：表示对应的文件描述符可以写；<br />
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br />
EPOLLERR：表示对应的文件描述符发生错误；<br />
EPOLLHUP：表示对应的文件描述符被挂断；<br />
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br />
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<p><strong>3. 等待epfd上的io事件</strong><br />
<code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br />
最多返回maxevents个事件。<br />
参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h4>2、工作模式</h4>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：<br />
LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br />
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<p><strong>1. LT模式</strong><br />
LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<p><strong>2. ET模式</strong><br />
ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p><strong>3. 总结</strong><br />
假如有这样一个例子：<br />
1. 我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符<br />
2. 这个时候从管道的另一端被写入了2KB的数据<br />
3. 调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作<br />
4. 然后我们读取了1KB的数据<br />
5. 调用epoll_wait(2)&#8230;&#8230;</p>
<p><strong>LT模式：</strong><br />
如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>
<p><strong>ET模式：</strong><br />
如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>
<p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后， 读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<blockquote><p>while(rs){<br />
buflen = recv(activeevents[i].data.fd, buf, sizeof(buf), 0);<br />
if(buflen &lt; 0){<br />
~~~~// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读<br />
~~~~// 在这里就当作是该次事件已处理处.<br />
~~~~if(errno == EAGAIN){<br />
~~~~~~~~break;<br />
~~~~}<br />
~~~~else{<br />
~~~~~~~~return;<br />
~~~~}<br />
}<br />
else if(buflen == 0){<br />
~~~~ // 这里表示对端的socket已正常关闭.<br />
}</p>
<p>if(buflen == sizeof(buf){<br />
~~~~ rs = 1; // 需要再次读取<br />
}<br />
else{<br />
~~~~ rs = 0;<br />
}<br />
}</p></blockquote>
<p>Linux中的EAGAIN含义<br />
Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。 从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>
<p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。 又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p>
<h4>3、代码演示</h4>
<p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>
<blockquote><p>#define IPADDRESS &#8220;127.0.0.1&#8221;<br />
#define PORT~~~~~~~~8787<br />
#define MAXSIZE~~~~ 1024<br />
#define LISTENQ~~~~ 5<br />
#define FDSIZE~~~~ 1000<br />
#define EPOLLEVENTS 100</p>
<p>listenfd = socket_bind(IPADDRESS,PORT);</p>
<p>struct epoll_event events[EPOLLEVENTS];</p>
<p>//创建一个描述符<br />
epollfd = epoll_create(FDSIZE);</p>
<p>//添加监听描述符事件<br />
add_event(epollfd,listenfd,EPOLLIN);</p>
<p>//循环等待<br />
for ( ; ; ){<br />
~~~~//该函数返回已经准备好的描述符事件数目<br />
~~~~ret = epoll_wait(epollfd,events,EPOLLEVENTS,-1);<br />
~~~~//处理接收到的连接<br />
~~~~handle_events(epollfd,events,ret,listenfd,buf);<br />
}</p>
<p>//事件处理函数<br />
static void handle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf)<br />
{<br />
~~~~ int i;<br />
~~~~ int fd;<br />
~~~~ //进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。<br />
~~~~ for (i = 0;i &lt; num;i++)<br />
~~~~ {<br />
~~~~~~~~ fd = events[i].data.fd;<br />
~~~~~~~~//根据描述符的类型和事件类型进行处理<br />
~~~~~~~~ if ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))<br />
~~~~~~~~~~~~handle_accpet(epollfd,listenfd);<br />
~~~~~~~~ else if (events[i].events &amp; EPOLLIN)<br />
~~~~~~~~~~~~do_read(epollfd,fd,buf);<br />
~~~~~~~~ else if (events[i].events &amp; EPOLLOUT)<br />
~~~~~~~~~~~~do_write(epollfd,fd,buf);<br />
~~~~ }<br />
}</p>
<p>//添加事件<br />
static void add_event(int epollfd,int fd,int state){<br />
~~~~struct epoll_event ev;<br />
~~~~ev.events = state;<br />
~~~~ev.data.fd = fd;<br />
~~~~epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);<br />
}</p>
<p>//处理接收到的连接<br />
static void handle_accpet(int epollfd,int listenfd){<br />
~~~~ int clifd;~~~~<br />
~~~~ struct sockaddr_in cliaddr;~~~~<br />
~~~~ socklen_t cliaddrlen;~~~~<br />
~~~~ clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);~~~~<br />
~~~~ if (clifd == -1)~~~~~~~~<br />
~~~~ perror(&#8220;accpet error:&#8221;);~~~~<br />
~~~~ else {~~~~~~~~<br />
~~~~~~~~ printf(&#8220;accept a new client: %s:%d\n&#8221;,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);~~~~~~~~~~~~~~~~~~~~ //添加一个客户描述符和事件~~~~~~~~<br />
~~~~~~~~ add_event(epollfd,clifd,EPOLLIN);~~~~<br />
~~~~ }<br />
}</p>
<p>//读处理<br />
static void do_read(int epollfd,int fd,char *buf){<br />
~~~~int nread;<br />
~~~~nread = read(fd,buf,MAXSIZE);<br />
~~~~if (nread == -1)~~~~ {~~~~~~~~<br />
~~~~~~~~perror(&#8220;read error:&#8221;);~~~~~~~~<br />
~~~~~~~~close(fd); //记住close fd~~~~~~~~<br />
~~~~~~~~delete_event(epollfd,fd,EPOLLIN); //删除监听<br />
~~~~}<br />
~~~~else if (nread == 0)~~~~ {~~~~~~~~<br />
~~~~~~~~fprintf(stderr,&#8221;client close.\n&#8221;);<br />
~~~~~~~~close(fd); //记住close fd~~~~<br />
~~~~~~~~delete_event(epollfd,fd,EPOLLIN); //删除监听<br />
~~~~}~~~~<br />
~~~~else {~~~~~~~~<br />
~~~~~~~~printf(&#8220;read message is : %s&#8221;,buf);~~~~~~~~<br />
~~~~~~~~//修改描述符对应的事件，由读改为写~~~~~~~~<br />
~~~~~~~~modify_event(epollfd,fd,EPOLLOUT);~~~~<br />
~~~~}<br />
}</p>
<p>//写处理<br />
static void do_write(int epollfd,int fd,char *buf) {~~~~<br />
~~~~int nwrite;~~~~<br />
~~~~nwrite = write(fd,buf,strlen(buf));~~~~<br />
~~~~if (nwrite == -1){~~~~~~~~<br />
~~~~~~~~perror(&#8220;write error:&#8221;);~~~~~~~~<br />
~~~~~~~~close(fd); //记住close fd~~~~<br />
~~~~~~~~delete_event(epollfd,fd,EPOLLOUT); //删除监听~~~~<br />
~~~~}else{<br />
~~~~~~~~modify_event(epollfd,fd,EPOLLIN);<br />
~~~~}~~~~<br />
~~~~memset(buf,0,MAXSIZE);<br />
}</p>
<p>//删除事件<br />
static void delete_event(int epollfd,int fd,int state) {<br />
~~~~struct epoll_event ev;<br />
~~~~ev.events = state;<br />
~~~~ev.data.fd = fd;<br />
~~~~epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);<br />
}</p>
<p>//修改事件<br />
static void modify_event(int epollfd,int fd,int state){~~~~<br />
~~~~struct epoll_event ev;<br />
~~~~ev.events = state;<br />
~~~~ev.data.fd = fd;<br />
~~~~epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);<br />
}</p></blockquote>
<p>//注：另外一端我就省了</p>
<h4>4、epoll总结</h4>
<p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p>epoll的优点主要是一下几个方面：<br />
1. 监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>
<p>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。<br />
如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p>
            </div>
        </div>
        <!-- 文章内容结束 -->
    </article>


</main><!-- .content-area -->

<div class="footer">
    <div class="container">

<div class="has-text-centered">
Copyright©2015-20178 cn-blogs.cn. All Rights Reserved. 鲁ICP备18001334号-2
</div>
    </div>
  </div>

</body>
</html>
