
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>HTTP状态码-4xx客户端错误 | 青春部落    </title>
    <meta name="keywords"  content="" />
    <meta name="description"  content="" />
    <link rel="stylesheet" type="text/css" media="all" href="https://cn-blogs.cn/wp-content/themes/pencilone/style.css" />
    <link rel="profile" href="http://gmpg.org/xfn/11">
    <link rel="pingback" href="https://cn-blogs.cn/xmlrpc.php">
    <link id="favicon" href="/favicon.ico" rel="icon" type="image/x-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="青春部落 &raquo; HTTP状态码-4xx客户端错误评论Feed" href="https://cn-blogs.cn/archives/2949.html/feed" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/cn-blogs.cn\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.9.1"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55358,56794,8205,9794,65039],[55358,56794,8203,9794,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='https://api.w.org/' href='https://cn-blogs.cn/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://cn-blogs.cn/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://cn-blogs.cn/wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='HTTP状态码-3xx重定向' href='https://cn-blogs.cn/archives/2947.html' />
<link rel='next' title='HTTP状态码-5xx服务器错误' href='https://cn-blogs.cn/archives/2951.html' />
<meta name="generator" content="WordPress 4.9.1" />
<link rel="canonical" href="https://cn-blogs.cn/archives/2949.html" />
<link rel='shortlink' href='https://cn-blogs.cn/?p=2949' />
<link rel="alternate" type="application/json+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F2949.html" />
<link rel="alternate" type="text/xml+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F2949.html&#038;format=xml" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-32x32.png" sizes="32x32" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-180x180.png" />
<meta name="msapplication-TileImage" content="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-270x270.png" />

<meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">


</head>

<body class="post-template-default single single-post postid-2949 single-format-standard">
<header class="navbar">
<div class="container">
    <div class="navbar-brand">
        <img src="/logo.png" width="73" height="88">
        <div>
        <h1 class="title2 is-3 navbar-item">
            <a href="https://cn-blogs.cn/" rel="home">青春部落</a>
        </h1>
        <p class="has-text-right">
            <a href="/">记录生活的足迹</a>
        </p>
        </div>
    </div>
    <div class="navbar-menu is-active">
    <div class="navbar-end">
    <div class="tabs is-right">
    <a class="navbar-item" href="/pages/index.html">索引</a>
    <a class="navbar-item" href="/about">About</a>
    </div>
    </div>
    </div>
</div>
</header>


<main class="container">
        <article class="article margin-top20">

        <!-- 文章分类和上一篇\下一篇 -->
        <div class="box columns">
            <!-- 文章分类 -->
            <div class="column is-two-fifth">
                <div class="categproe-name">分类：</div>
                <ul class="post-categories">
	<li><a href="https://cn-blogs.cn/archives/category/operation-tool/webserver" rel="category tag">Web服务</a></li></ul>            </div>
            <!-- 文章分类结束 -->

            <!-- 上一篇和下一篇 -->
            <div class="column is-two-fifth is-offset-5">
                
	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">Post navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://cn-blogs.cn/archives/2947.html" rel="prev">上一篇：HTTP状态码-3xx重定向</a></div><div class="nav-next"><a href="https://cn-blogs.cn/archives/2951.html" rel="next">下一篇：HTTP状态码-5xx服务器错误</a></div></div>
	</nav>            </div>
            <!-- 上一篇和下一篇结束 -->
        </div>

        <!-- 文章信息 -->
        <!-- 文章标题 -->
        <div class="title is-3 has-text-centered">
            HTTP状态码-4xx客户端错误        </div>
        <!-- 文章标题结束 -->

        <!-- 文章作者、发布时间、更新时间 -->
        <div class="subtitle is-5 has-text-centered">
            <span class="entry-author"><a href="https://cn-blogs.cn/archives/author/admin" title="由admin发布" rel="author">admin</a></span>
            <span class="entry-date">2016/04/14</span>
            <span class="update is-hidden">2018-01-24</span>
        </div>
        <!-- 文章作者、发布时间、更新时间结束 -->

        <!-- 文章内容 -->
        <div class="content article-body">
            <div class="content">
                <p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。<br />
除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。<br />
这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。<br />
如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p>
<p><strong>400 Bad Request</strong><br />
由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。</p>
<p><strong>401 Unauthorized（RFC 7235）</strong><br />
参见：HTTP基本认证、HTTP摘要认证<br />
类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。<br />
该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。<br />
如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。<br />
如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。<br />
注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。</p>
<p><strong>402 Payment Required</strong><br />
该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。</p>
<p><strong>403 Forbidden</strong><br />
服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。<br />
如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p>
<p><strong>404 Not Found</strong><br />
请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。<br />
没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。<br />
404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<p><strong>405 Method Not Allowed</strong><br />
请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。<br />
例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。<br />
鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<p><strong>406 Not Acceptable</strong><br />
参见：内容协商<br />
请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。<br />
除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。<br />
实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p>
<p><strong>407 Proxy Authentication Required（RFC 2617）</strong><br />
与401响应类似，只不过客户端必须在代理服务器上进行身份验证。[37]代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。</p>
<p><strong>408 Request Timeout</strong><br />
请求超时。根据HTTP规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。</p>
<p><strong>409 Conflict</strong><br />
表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。</p>
<p><strong>410 Gone</strong><br />
表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到410状态码后，用户应停止再次请求资源。但大多数服务端不会使用此状态码，而是直接使用404状态码。</p>
<p><strong>411 Length Required</strong><br />
服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。</p>
<p><strong>412 Precondition Failed（RFC 7232）</strong><br />
服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p>
<p><strong>413 Request Entity Too Large（RFC 7231）</strong><br />
前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。<br />
此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br />
如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<p><strong>414 Request-URI Too Long（RFC 7231）</strong><br />
前称“Request-URI Too Long”，表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。<br />
通常将太多数据的结果编码为GET请求的查询字符串，在这种情况下，应将其转换为POST请求。[44]这比较少见，通常的情况包括：<br />
本应使用POST方法的表单提交变成了GET方法，导致查询字符串过长。<br />
重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。<br />
客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。<br />
没有此类漏洞的服务器，应当返回414状态码。</p>
<p><strong>415 Unsupported Media Type</strong><br />
对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为svg，但服务器要求图像使用上传格式为jpg。</p>
<p><strong>416 Requested Range Not Satisfiable（RFC 7233）</strong><br />
前称“Requested Range Not Satisfiable”。[46]客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。</p>
<p><strong>417 Expectation Failed</strong><br />
在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。</p>
<p><strong>418 I&#8217;m a teapot（RFC 2324）</strong><br />
本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324超文本咖啡壶控制协议&#8217;中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。[49]这个HTTP状态码在某些网站（包括Google.com）与项目（如Node.js、ASP.NET和Go语言）中用作彩蛋。</p>
<p><strong>420 Enhance Your Caim</strong><br />
Twitter Search与Trends API在客户端被限速的情况下返回。</p>
<p><strong>421 Misdirected Request （RFC 7540）</strong><br />
该请求针对的是无法产生响应的服务器（例如因为连接重用）。</p>
<p><strong>422 Unprocessable Entity（WebDAV；RFC 4918 ）</strong><br />
请求格式正确，但是由于含有语义错误，无法响应。</p>
<p><strong>423 Locked（WebDAV；RFC 4918）</strong><br />
当前资源被锁定。</p>
<p><strong>424 Failed Dependency（WebDAV；RFC 4918）</strong><br />
由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。</p>
<p><strong>425 Unodered Cellection</strong><br />
在WebDAV Advanced Collections Protocol中定义，但Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol中并不存在。</p>
<p><strong>426 Upgrade Required（RFC 2817）</strong><br />
客户端应当切换到TLS/1.0，并在HTTP/1.1 Upgrade header中给出。</p>
<p><strong>428 Precondition Required (RFC 6585)</strong><br />
原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”</p>
<p><strong>429 Too Many Requests （RFC 6585）</strong><br />
用户在给定的时间内发送了太多的请求。旨在用于网络限速。</p>
<p><strong>431 Request Header Fields Too Large （RFC 6585）</strong><br />
服务器不愿处理请求，因为一个或多个头字段过大。</p>
<p><strong>444 No Response</strong><br />
Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。</p>
<p><strong>450 Blocked by Windows Parental Controls</strong><br />
这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。</p>
<p><strong>451 Unavailable For Legal Reasons</strong><br />
该访问因法律的要求而被拒绝，由IETF在2015核准后新增加。</p>
<p><strong>494 Request Header Too Large</strong><br />
在错误代码431提出之前Nginx上使用的扩展HTTP代码。</p>
            </div>
        </div>
        <!-- 文章内容结束 -->
    </article>


</main><!-- .content-area -->

<div class="footer">
    <div class="container">

<div class="has-text-centered">
Copyright©2015-20178 cn-blogs.cn. All Rights Reserved. 鲁ICP备18001334号-2
</div>
    </div>
  </div>

</body>
</html>
