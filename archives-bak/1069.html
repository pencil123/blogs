
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>mro  继承类中的 方法解析顺序 | 青春部落    </title>
    <meta name="keywords"  content="" />
    <meta name="description"  content="" />
    <link rel="stylesheet" type="text/css" media="all" href="https://cn-blogs.cn/wp-content/themes/pencilone/style.css" />
    <link rel="profile" href="http://gmpg.org/xfn/11">
    <link rel="pingback" href="https://cn-blogs.cn/xmlrpc.php">
    <link id="favicon" href="/favicon.ico" rel="icon" type="image/x-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="青春部落 &raquo; mro  继承类中的 方法解析顺序评论Feed" href="https://cn-blogs.cn/archives/1069.html/feed" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/cn-blogs.cn\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.9.1"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55358,56794,8205,9794,65039],[55358,56794,8203,9794,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='https://api.w.org/' href='https://cn-blogs.cn/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://cn-blogs.cn/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://cn-blogs.cn/wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='tornado ioloop  1、  linux epoll' href='https://cn-blogs.cn/archives/1060.html' />
<link rel='next' title='ioloop_Configurable_EPollIOLoop_PollIOLoop_ioloop 之间的关系' href='https://cn-blogs.cn/archives/1077.html' />
<meta name="generator" content="WordPress 4.9.1" />
<link rel="canonical" href="https://cn-blogs.cn/archives/1069.html" />
<link rel='shortlink' href='https://cn-blogs.cn/?p=1069' />
<link rel="alternate" type="application/json+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F1069.html" />
<link rel="alternate" type="text/xml+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F1069.html&#038;format=xml" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-32x32.png" sizes="32x32" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-180x180.png" />
<meta name="msapplication-TileImage" content="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-270x270.png" />

<meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">


</head>

<body class="post-template-default single single-post postid-1069 single-format-standard">
<header class="navbar">
<div class="container">
    <div class="navbar-brand">
        <img src="/logo.png" width="73" height="88">
        <div>
        <h1 class="title2 is-3 navbar-item">
            <a href="https://cn-blogs.cn/" rel="home">青春部落</a>
        </h1>
        <p class="has-text-right">
            <a href="/">记录生活的足迹</a>
        </p>
        </div>
    </div>
    <div class="navbar-menu is-active">
    <div class="navbar-end">
    <div class="tabs is-right">
    <a class="navbar-item" href="/pages/index.html">索引</a>
    <a class="navbar-item" href="/about">About</a>
    </div>
    </div>
    </div>
</div>
</header>


<main class="container">
        <article class="article margin-top20">

        <!-- 文章分类和上一篇\下一篇 -->
        <div class="box columns">
            <!-- 文章分类 -->
            <div class="column is-two-fifth">
                <div class="categproe-name">分类：</div>
                <ul class="post-categories">
	<li><a href="https://cn-blogs.cn/archives/category/development/python" rel="category tag">Python</a></li></ul>            </div>
            <!-- 文章分类结束 -->

            <!-- 上一篇和下一篇 -->
            <div class="column is-two-fifth is-offset-5">
                
	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">Post navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://cn-blogs.cn/archives/1060.html" rel="prev">上一篇：tornado ioloop  1、  linux epoll</a></div><div class="nav-next"><a href="https://cn-blogs.cn/archives/1077.html" rel="next">下一篇：ioloop_Configurable_EPollIOLoop_PollIOLoop_ioloop 之间的关系</a></div></div>
	</nav>            </div>
            <!-- 上一篇和下一篇结束 -->
        </div>

        <!-- 文章信息 -->
        <!-- 文章标题 -->
        <div class="title is-3 has-text-centered">
            mro  继承类中的 方法解析顺序        </div>
        <!-- 文章标题结束 -->

        <!-- 文章作者、发布时间、更新时间 -->
        <div class="subtitle is-5 has-text-centered">
            <span class="entry-author"><a href="https://cn-blogs.cn/archives/author/admin" title="由admin发布" rel="author">admin</a></span>
            <span class="entry-date">2016/12/27</span>
            <span class="update is-hidden">2017-09-11</span>
        </div>
        <!-- 文章作者、发布时间、更新时间结束 -->

        <!-- 文章内容 -->
        <div class="content article-body">
            <div class="content">
                <p>对于支持继承的编程语言来说，其方法（属性）可能定义在当前类，也可能来自于基类，所以在方法调用时就需要对当前类和基类进行搜索以确定方法所在的位置。而搜索的顺序就是所谓的「方法解析顺序」（Method Resolution Order，或MRO）。对于只支持单继承的语言来说，MRO 一般比较简单；而对于 Python 这种支持多继承的语言来说，MRO 就复杂很多。</p>
<p>先看一个「菱形继承」的例子：<br />
<a href="http://www.cn-blogs.cn/wp-content/uploads/2016/12/star.png"><img class="alignnone size-full wp-image-1070" src="http://www.cn-blogs.cn/wp-content/uploads/2016/12/star.png" alt="star" width="265" height="322" srcset="https://cn-blogs.cn/wp-content/uploads/2016/12/star.png 265w, https://cn-blogs.cn/wp-content/uploads/2016/12/star-247x300.png 247w" sizes="(max-width: 265px) 100vw, 265px" /></a></p>
<p>菱形继承<br />
如果 x 是 D 的一个实例，那么 x.show() 到底会调用哪个 show 方法呢？如果按照 [D, B, A, C] 的搜索顺序，那么 x.show() 会调用 A.show()；如果按照 [D, B, C, A] 的搜索顺序，那么 x.show() 会调用 C.show()。由此可见，MRO 是把类的继承关系线性化的一个过程，而线性化方式决定了程序运行过程中具体会调用哪个方法。既然如此，那什么样的 MRO 才是最合理的？Python 中又是如何实现的呢？</p>
<p><strong>Python 至少有三种不同的 MRO：</strong></p>
<p><strong>经典类（classic class）的深度遍历。<br />
Python 2.2 的新式类（new-style class）预计算。<br />
Python 2.3 的新式类的 C3 算法。它也是 Python 3 唯一支持的方式。<br />
经典类的 MRO</strong></p>
<p>Python 有两种类：经典类（classic class）和新式类（new-style class）。两者的不同之处在于新式类继承自 object。在 Python 2.1 以前，经典类是唯一可用的形式；Python 2.2 引入了新式类，使得类和内置类型更加统一；在 Python 3 中，新式类是唯一支持的类。</p>
<p>经典类采用了一种很简单的 MRO 方法：从左至右的深度优先遍历。以上述「菱形继承」为例，其查找顺序为 [D, B, A, C, A]，如果只保留重复类的第一个则结果为 [D, B, A, C]。我们可以用 inspect.getmro 来获取类的 MRO：</p>
<p>&gt;&gt;&gt; import inspect<br />
&gt;&gt;&gt; class A:<br />
&#8230; def show(self):<br />
&#8230; print &#8220;A.show()&#8221;<br />
&#8230;<br />
&gt;&gt;&gt; class B(A): pass<br />
&gt;&gt;&gt; class C(A):<br />
&#8230; def show(self):<br />
&#8230; print &#8220;C.show()&#8221;<br />
&#8230;<br />
&gt;&gt;&gt; class D(B, C): pass<br />
&gt;&gt;&gt; inspect.getmro(D)<br />
(, , , )<br />
&gt;&gt;&gt; x = D()<br />
&gt;&gt;&gt; x.show()<br />
A.show()<br />
这种深度优先遍历对于简单的情况还能处理的不错，但是对于上述「菱形继承」其结果却不尽如人意：虽然 C.show() 是 A.show() 的更具体化版本（显示了更多的信息），但我们的 x.show() 没有调用它，而是调用了 A.show()。这显然不是我们希望的结果。</p>
<p>对于新式类而言，所有的类都继承自 object，所以「菱形继承」是非常普遍的现象，因此不可能采用这种 MRO 方式。</p>
<p><strong>Python 2.2 的新式类 MRO</strong></p>
<p>为解决经典类 MRO 所存在的问题，Python 2.2 针对新式类提出了一种新的 MRO 计算方式：在定义类时就计算出该类的 MRO 并将其作为类的属性。因此新式类可以直接通过 __mro__ 属性获取类的 MRO。</p>
<p>Python 2.2 的新式类 MRO 计算方式和经典类 MRO 的计算方式非常相似：它仍然采用从左至右的深度优先遍历，但是如果遍历中出现重复的类，只保留最后一个。重新考虑上面「菱形继承」的例子，由于新式类继承自 object 因此类图稍有改变：<a href="http://www.cn-blogs.cn/wp-content/uploads/2016/12/starr.png"><img class="alignnone size-full wp-image-1071" src="http://www.cn-blogs.cn/wp-content/uploads/2016/12/starr.png" alt="starr" width="278" height="433" srcset="https://cn-blogs.cn/wp-content/uploads/2016/12/starr.png 278w, https://cn-blogs.cn/wp-content/uploads/2016/12/starr-193x300.png 193w" sizes="(max-width: 278px) 100vw, 278px" /></a></p>
<p>新式类菱形继承<br />
按照深度遍历，其顺序为 [D, B, A, object, C, A, object]，重复类只保留最后一个，因此变为 [D, B, C, A, object]。代码为：</p>
<p>&gt;&gt;&gt; class A(object):<br />
&#8230; def show(self):<br />
&#8230; print &#8220;A.show()&#8221;<br />
&#8230;<br />
&gt;&gt;&gt; class B(A): pass<br />
&gt;&gt;&gt; class C(A):<br />
&#8230; def show(self):<br />
&#8230; print &#8220;C.show()&#8221;<br />
&#8230;<br />
&gt;&gt;&gt; class D(B, C): pass<br />
&gt;&gt;&gt; D.__mro__<br />
(&lt;class &#8216;__main__.D&#8217;&gt;, &lt;class &#8216;__main__.B&#8217;&gt;, &lt;class &#8216;__main__.C&#8217;&gt;, &lt;class &#8216;__main__.A&#8217;&gt;, &lt;type &#8216;object&#8217;&gt;)<br />
&gt;&gt;&gt; x = D()<br />
&gt;&gt;&gt; x.show()<br />
C.show()<br />
这种 MRO 方式已经能够解决「菱形继承」问题，再让我们看个稍微复杂点的例子：</p>
<p><a href="http://www.cn-blogs.cn/wp-content/uploads/2016/12/starrr.png"><img class="alignnone size-full wp-image-1072" src="http://www.cn-blogs.cn/wp-content/uploads/2016/12/starrr.png" alt="starrr" width="275" height="410" srcset="https://cn-blogs.cn/wp-content/uploads/2016/12/starrr.png 275w, https://cn-blogs.cn/wp-content/uploads/2016/12/starrr-201x300.png 201w" sizes="(max-width: 275px) 100vw, 275px" /></a></p>
<p>类型冲突<br />
&gt;&gt;&gt; class X(object): pass<br />
&gt;&gt;&gt; class Y(object): pass<br />
&gt;&gt;&gt; class A(X, Y): pass<br />
&gt;&gt;&gt; class B(Y, X): pass<br />
&gt;&gt;&gt; class C(A, B): pass<br />
首先进行深度遍历，结果为 [C, A, X, object, Y, object, B, Y, object, X, object]；然后，只保留重复元素的最后一个，结果为 [C, A, B, Y, X, object]。Python 2.2 在实现该方法的时候进行了调整，使其更尊重基类中类出现的顺序，其实际结果为 [C, A, B, X, Y, object]。</p>
<p>这样的结果是否合理呢？首先我们看下各个类中的方法解析顺序：对于 A 来说，其搜索顺序为 [A, X, Y, object]；对于 B，其搜索顺序为 [B, Y, X, object]；对于 C，其搜索顺序为 [C, A, B, X, Y, object]。我们会发现，B 和 C 中 X、Y 的搜索顺序是相反的！也就是说，当 B 被继承时，它本身的行为竟然也发生了改变，这很容易导致不易察觉的错误。此外，即使把 C 搜索顺序中 X 和 Y 互换仍然不能解决问题，这时候它又会和 A 中的搜索顺序相矛盾。</p>
<p>事实上，不但上述特殊情况会出现问题，在其它情况下也可能出问题。其原因在于，上述继承关系违反了线性化的「 单调性原则 」。Michele Simionato对单调性的定义为：</p>
<p>A MRO is monotonic when the following is true: if C1 precedes C2 in the linearization of C, then C1 precedes C2 in the linearization of any subclass of C. Otherwise, the innocuous operation of deriving a new class could change the resolution order of methods, potentially introducing very subtle bugs.</p>
<p>也就是说，子类不能改变基类的方法搜索顺序。在 Python 2.2 的 MRO 算法中并不能保证这种单调性，它不会阻止程序员写出上述具有二义性的继承关系，因此很可能成为错误的根源。</p>
<p>除了单调性之外，Python 2.2 及 经典类的 MRO 也可能违反继承的「 局部优先级 」，具体例子可以参见官方文档。采用一种更好的 MRO 方式势在必行。</p>
<p><strong>C3 MRO</strong></p>
<p>为解决 Python 2.2 中 MRO 所存在的问题，Python 2.3以后采用了 C3 方法来确定方法解析顺序。你如果在 Python 2.3 以后版本里输入上述代码，就会产生一个异常，禁止创建具有二义性的继承关系：</p>
<p>&gt;&gt;&gt; class C(A, B): pass<br />
Traceback (most recent call last):<br />
File &#8220;&#8221;, line 1, in<br />
class C(A, B): pass<br />
TypeError: Error when calling the metaclass bases<br />
Cannot create a consistent method resolution<br />
order (MRO) for bases X, Y<br />
我们把类 C 的线性化（MRO）记为 L[C] = [C1, C2,…,CN]。其中 C1 称为 L[C] 的头，其余元素 [C2,…,CN] 称为尾。如果一个类 C 继承自基类 B1、B2、……、BN，那么我们可以根据以下两步计算出 L[C]：</p>
<p>L[object] = [object]<br />
L[C(B1…BN)] = [C] + merge(L[B1]…L[BN], [B1]…[BN])<br />
这里的关键在于 merge，其输入是一组列表，按照如下方式输出一个列表：</p>
<p>检查第一个列表的头元素（如 L[B1] 的头），记作 H。<br />
若 H 未出现在其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤1；否则，取出下一个列表的头部记作 H，继续该步骤。<br />
重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，说明无法构建继承关系，Python 会抛出异常。<br />
该方法有点类似于图的拓扑排序，但它同时还考虑了基类的出现顺序。我们用 C3 分析一下刚才的例子。</p>
<p>object，X，Y 的线性化结果比较简单：</p>
<p>L[object] = [object]<br />
L[X] = [X, object]<br />
L[Y] = [Y, object]<br />
A 的线性化计算如下：</p>
<p>L[A] = [A] + merge(L[X], L[Y], [X], [Y])<br />
= [A] + merge([X, object], [Y, object], [X], [Y])<br />
= [A, X] + merge([object], [Y, object], [Y])<br />
= [A, X, Y] + merge([object], [object])<br />
= [A, X, Y, object]<br />
注意第3步，merge([object], [Y, object], [Y]) 中首先输出的是 Y 而不是 object。这是因为 object 虽然是第一个列表的头，但是它出现在了第二个列表的尾部。所以我们会跳过第一个列表，去检查第二个列表的头部，也就是 Y。Y 没有出现在其它列表的尾部，所以将其输出。</p>
<p>同理，B 的线性化结果为：</p>
<p>L[B] = [B, Y, X, object]<br />
最后，我们看看 C 的线性化结果：</p>
<p>L[C] = [C] + merge(L[A], L[B], [A], [B])<br />
= [C] + merge([A, X, Y, object], [B, Y, X, object], [A], [B])<br />
= [C, A] + merge([X, Y, object], [B, Y, X, object], [B])<br />
= [C, A, B] + merge([X, Y, object], [Y, X, object])<br />
到了最后一步我们没有办法继续计算下去 了：X 虽然是第一个列表的头，但是它出现在了第二个列表的尾部；Y 虽然是第二个列表的头，但是它出现在了第一个列表的尾部。因此，我们无法构建一个没有二义性的继承关系，只能手工去解决（比如改变 B 基类中 X、Y 的顺序）。</p>
<p>我们再看一个没有冲突的例子：</p>
<p><a href="http://www.cn-blogs.cn/wp-content/uploads/2016/12/star4.png"><img class="alignnone size-full wp-image-1073" src="http://www.cn-blogs.cn/wp-content/uploads/2016/12/star4.png" alt="star4" width="349" height="396" srcset="https://cn-blogs.cn/wp-content/uploads/2016/12/star4.png 349w, https://cn-blogs.cn/wp-content/uploads/2016/12/star4-264x300.png 264w" sizes="(max-width: 349px) 100vw, 349px" /></a></p>
<p>C3例子<br />
计算过程如下：</p>
<p>L[object] = [object]<br />
L[D] = [D, object]<br />
L[E] = [E, object]<br />
L[F] = [F, object]<br />
L[B] = [B, D, E, object]<br />
L[C] = [C, D, F, object]<br />
L[A] = [A] + merge(L[B], L[C], [B], [C])<br />
= [A] + merge([B, D, E, object], [C, D, F, object], [B], [C])<br />
= [A, B] + merge([D, E, object], [C, D, F, object], [C])<br />
= [A, B, C] + merge([D, E, object], [D, F, object])<br />
= [A, B, C, D] + merge([E, object], [F, object])<br />
= [A, B, C, D, E] + merge([object], [F, object])<br />
= [A, B, C, D, E, F] + merge([object], [object])<br />
= [A, B, C, D, E, F, object]<br />
当然，可以用代码验证类的 MRO，上面的例子可以写作：</p>
<p>&gt;&gt;&gt; class D(object): pass<br />
&gt;&gt;&gt; class E(object): pass<br />
&gt;&gt;&gt; class F(object): pass<br />
&gt;&gt;&gt; class B(D, E): pass<br />
&gt;&gt;&gt; class C(D, F): pass<br />
&gt;&gt;&gt; class A(B, C): pass<br />
&gt;&gt;&gt; A.__mro__<br />
(&lt;class &#8216;__main__.A&#8217;&gt;, &lt;class &#8216;__main__.B&#8217;&gt;, &lt;class &#8216;__main__.C&#8217;&gt;, &lt;class &#8216;__main__.D&#8217;&gt;, &lt;class &#8216;__main__.E&#8217;&gt;, &lt;class &#8216;__main__.F&#8217;&gt;, &lt;type &#8216;object&#8217;&gt;)</p>
            </div>
        </div>
        <!-- 文章内容结束 -->
    </article>


</main><!-- .content-area -->

<div class="footer">
    <div class="container">

<div class="has-text-centered">
Copyright©2015-20178 cn-blogs.cn. All Rights Reserved. 鲁ICP备18001334号-2
</div>
    </div>
  </div>

</body>
</html>
