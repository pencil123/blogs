
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>系统内存和虚拟内存(SWAP)说明 | 青春部落    </title>
    <meta name="keywords"  content="内存,系统内存,虚拟内存,SWAP" />
    <meta name="description"  content="系统内存说明和虚拟内存说明" />
    <link rel="stylesheet" type="text/css" media="all" href="https://cn-blogs.cn/wp-content/themes/pencilone/style.css" />
    <link rel="profile" href="http://gmpg.org/xfn/11">
    <link rel="pingback" href="https://cn-blogs.cn/xmlrpc.php">
    <link id="favicon" href="/favicon.ico" rel="icon" type="image/x-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="青春部落 &raquo; 系统内存和虚拟内存(SWAP)说明评论Feed" href="https://cn-blogs.cn/archives/2113.html/feed" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/cn-blogs.cn\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.9.1"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55358,56794,8205,9794,65039],[55358,56794,8203,9794,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='https://api.w.org/' href='https://cn-blogs.cn/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://cn-blogs.cn/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://cn-blogs.cn/wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='进程使用内存的不同指标' href='https://cn-blogs.cn/archives/2109.html' />
<link rel='next' title='邮件域名解析' href='https://cn-blogs.cn/archives/2218.html' />
<meta name="generator" content="WordPress 4.9.1" />
<link rel="canonical" href="https://cn-blogs.cn/archives/2113.html" />
<link rel='shortlink' href='https://cn-blogs.cn/?p=2113' />
<link rel="alternate" type="application/json+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F2113.html" />
<link rel="alternate" type="text/xml+oembed" href="https://cn-blogs.cn/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcn-blogs.cn%2Farchives%2F2113.html&#038;format=xml" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-32x32.png" sizes="32x32" />
<link rel="icon" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-180x180.png" />
<meta name="msapplication-TileImage" content="https://cn-blogs.cn/wp-content/uploads/2018/03/cropped-logo-270x270.png" />

<meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">


</head>

<body class="post-template-default single single-post postid-2113 single-format-standard">
<header class="navbar">
<div class="container">
    <div class="navbar-brand">
        <img src="/logo.png" width="73" height="88">
        <div>
        <h1 class="title2 is-3 navbar-item">
            <a href="https://cn-blogs.cn/" rel="home">青春部落</a>
        </h1>
        <p class="has-text-right">
            <a href="/">记录生活的足迹</a>
        </p>
        </div>
    </div>
    <div class="navbar-menu is-active">
    <div class="navbar-end">
    <div class="tabs is-right">
    <a class="navbar-item" href="/pages/index.html">索引</a>
    <a class="navbar-item" href="/about">About</a>
    </div>
    </div>
    </div>
</div>
</header>


<main class="container">
        <article class="article margin-top20">

        <!-- 文章分类和上一篇\下一篇 -->
        <div class="box columns">
            <!-- 文章分类 -->
            <div class="column is-two-fifth">
                <div class="categproe-name">分类：</div>
                <ul class="post-categories">
	<li><a href="https://cn-blogs.cn/archives/category/kernel/hard-system" rel="category tag">内核&amp;硬件系统</a></li></ul>            </div>
            <!-- 文章分类结束 -->

            <!-- 上一篇和下一篇 -->
            <div class="column is-two-fifth is-offset-5">
                
	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">Post navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://cn-blogs.cn/archives/2109.html" rel="prev">上一篇：进程使用内存的不同指标</a></div><div class="nav-next"><a href="https://cn-blogs.cn/archives/2218.html" rel="next">下一篇：邮件域名解析</a></div></div>
	</nav>            </div>
            <!-- 上一篇和下一篇结束 -->
        </div>

        <!-- 文章信息 -->
        <!-- 文章标题 -->
        <div class="title is-3 has-text-centered">
            系统内存和虚拟内存(SWAP)说明        </div>
        <!-- 文章标题结束 -->

        <!-- 文章作者、发布时间、更新时间 -->
        <div class="subtitle is-5 has-text-centered">
            <span class="entry-author"><a href="https://cn-blogs.cn/archives/author/admin" title="由admin发布" rel="author">admin</a></span>
            <span class="entry-date">2017/10/20</span>
            <span class="update is-hidden">2018-04-26</span>
        </div>
        <!-- 文章作者、发布时间、更新时间结束 -->

        <!-- 文章内容 -->
        <div class="content article-body">
            <div class="content">
                <h2>1、系统内存使用</h2>
<p>操作系统的内存一般理解为虚拟内存；包括系统的RAM和SWAP两个存储单元。系统在申请，管理和回收内存时，使用虚拟内存技术管理内存空间。<br />
系统在使用内存的机制上，除了对申请内存的进程分配内存空间外，还会为了提供运行速度进行数据的缓存和缓冲。<br />
对SWAP分区的使用中，可以设置RAM使用率大约多少时，还是使用SWAP分区。避免SWAP分区提前使用，影响性能。</p>
<h4>查看内存使用</h4>
<p><img class="alignnone size-full wp-image-51" src="http://www.cn-blogs.cn/wp-content/uploads/2016/05/linux_memory.jpg" alt="linux_memory" width="703" height="460" srcset="https://cn-blogs.cn/wp-content/uploads/2016/05/linux_memory.jpg 703w, https://cn-blogs.cn/wp-content/uploads/2016/05/linux_memory-300x196.jpg 300w" sizes="(max-width: 703px) 100vw, 703px" /></p>
<h4>Mem 行参数说明</h4>
<p>MEM total:物理内存的总量<br />
MEM userd:系统已经使用的内存量（包括cached和buffers）<br />
MEM free:系统未使用的内存量（真正空闲的）<br />
MEM shared:多个进程共享的内存量<br />
MEM buffers:磁盘缓冲（buffer cache）的量<br />
MEM cached:磁盘缓存（page cache）的量</p>
<h4>Buffers/Cache 行参数说明</h4>
<p>used:进程使用的内存量：used-buffers-cached<br />
free:还可以申请的内存量：free+buffers+cached<br />
<strong>buffers</strong>是用来给块设备做的缓冲大小、buffers是用来存储目录里面有什么内容，权限<br />
<strong>cached</strong>用来给文件做缓冲，用来记忆我们打开的文件.</p>
<h2>2、缓存和缓冲管理</h2>
<p>Linux系统设计为尽量的使用内存，来提高系统运行速度；因为从磁盘中读取数据比从内存中读取慢很多。<br />
这部分用于提高系统速度而Cached和buffers占用的物理内存，会在进程申请内存时还给操作系统，用于分配给申请进程。<br />
不过即使你的程序运行结束后，Cache Memory也不会自动释放。<br />
这就会导致你在Linux系统中程序频繁读写文件后，你会发现可用物理内存(free)会很少。</p>
<h3>释放系统缓存和缓冲</h3>
<p>可以修改系统内核drop_caches指令，达到释放内存中的缓存的功能。<br />
<strong>注意：</strong>在释放内存中的缓存之前，要保证内存中缓存的数据已经刷到硬盘中；否则会造成数据丢失。</p>
<h4>指令说明</h4>
<p><code>/proc/sys/vm/drop_caches (since Linux 2.6.16)<br />
Writing to this file causes the kernel to drop clean caches,dentries and inodes from memory, causing that memory to become free.<br />
To free pagecache(页缓存), use echo 1 &gt; /proc/sys/vm/drop_caches;<br />
to free dentries(目录项) and inodes(索引节点), use echo 2 &gt; /proc/sys/vm/drop_caches;<br />
to free pagecache, dentries and inodes, use echo 3 &gt; /proc/sys/vm/drop_caches.</code></p>
<p><code>As this is a non-destructive operation, and dirty objects are not freeable, the user should run “sync” first in order to make sure all cached objects are freed.</code><br />
由于这是一个非破坏性的操作，并且脏对象不可用，用户应首先运行“sync”，以确保所有缓存对象都被释放。</p>
<h4>后续状态</h4>
<p>如果执行了释放系统缓存的操作，那么有两种可能性：<br />
1、系统以后就不再缓存数据了。<br />
2、系统马上开始重新缓存数据。</p>
<p><strong>实际上第2中可能性是正确的</strong><br />
Basically when you write to that file you aren’t really changing a setting, you are issuing a command to the kernel.<br />
The kernel acts on that command (by dropping the caches) then carries on as before.<br />
缓冲:作为buffer cache的内存,是块设备的读写缓冲区<br />
缓存:作为page cache的内存,文件系统的缓存。如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小。</p>
<h3>刷新进程</h3>
<p>pdflush daemon 用来同步文件相关的内存页面，把内存页面及时同步到硬盘上。<br />
比如打开一个文件，文件被导入到内存里，对文件做了修改后并保存后，内核并不马上保存文件到硬盘，由 pdflush 决定什么时候把相应页面写入硬盘，这由一个内核参数 vm.dirty_background_ratio 来控制.<br />
如下面的参数显示脏页面（dirty pages）达到所有内存页面10％的时候开始写入硬盘。<br />
<code># /sbin/sysctl -n vm.dirty_background_ratio<br />
10</code></p>
<h2>3、SWAP 分区说明</h2>
<p>SWAP分区是扩展一部分磁盘空间，用于存储内存中不活跃的数据。<br />
<strong>好处</strong>：增加了系统运行时可以加载的数据量，这样就可以运行更大、更多的程序。<br />
<strong>坏处</strong>：SWAP分区中的数据读写速度自然比RAM中慢很多，使用虚拟内存会削弱内存表的一部分优势；尽量的使用RAM。</p>
<h4>SWAP分区使用|页面交换</h4>
<p>操作系统里，虚拟内存被分成页，在x86系统上每个页（getconf PAGE_SIZE）大小是4KB。<br />
Linux 内核读写虚拟内存是以 “页” 为单位操作的，把内存转移到硬盘交换空间（SWAP）和从交换空间读取到内存的时候都是按页来读写的。内存和 SWAP 的这种交换过程称为页面交换（Paging）。</p>
<h4>页面交换进程：kswapd0</h4>
<p><code>Linux uses kswapd for virtual memory management such that pages that have been recently accessed are kept in memory and less active pages are paged out to disk.<br />
(what is a page?)…Linux uses manages memory in units called pages.<br />
So,the kswapd process regularly decreases the ages of unreferenced pages…and at the end they are paged out(moved out) to disk</code><br />
<strong>kswapd0进程是虚拟内存管理中，负责换页的进程。</strong><br />
操作系统每过一定时间就会唤醒kswapd ，看看内存是否紧张，如果不紧张，则睡眠。<br />
在kswapd中，有2个阀值，pages_hige 和 pages_low，当空闲内存页的数量低于 pages_low的时候，kswapd进程就会扫描内存并且每次释放出32 个free pages，直到 free page 的数量到达pages_high。</p>
<h4>优化kswapd0进程</h4>
<p>linux系统在RAM还有空余的情况下，就开始使用SWAP分区；这样会降低系统运行的速度。<br />
优化kswapd0什么时候开始使用SWAP分区；通过vm.swappiness 内核参数控制</p>
<p><strong>swappiness内核参数</strong><br />
<code>Swappiness is a Linux kernel parameter that controls the relative weight given to swapping out of runtime memory, as opposed to dropping pages from the system page cache. </code><br />
提供一个相对权重参数，用于控制运行内存的页面交换；而不是降低系统页面缓存。<br />
<code>Swappiness can be set to values between 0 and 100 inclusive.<br />
A low value causes the kernel to avoid swapping; a higher value causes the kernel to try to use swap space. </code><br />
低值使内核避免交换；高值使内核尝试进行页面交换。</p>
<h4>swappiness 几种配置</h4>
<table>
<tbody>
<tr>
<th>vm.swappiness = 0</th>
<th>不要使用这个配置</th>
</tr>
<tr>
<th>vm.swappiness = 1</th>
<th>Kernel version 3.5；Minimum amount of swapping without disabling it entirely(最小交换量，而不会禁止SWAP).the kernel would swap only to avoid an out of memory condition, when free memory will be below vm.min_free_kbytes limit.</th>
</tr>
<tr>
<th>vm.swappiness = 10</th>
<th>(建议内存足够时使用)This value is sometimes recommended to improve performance when sufficient memory exists in a system.</th>
</tr>
<tr>
<th>vm.swappiness = 60</th>
<th>The default value.</th>
</tr>
<tr>
<th>vm.swappiness = 100</th>
<th>The kernel will swap aggressively.</th>
</tr>
</tbody>
</table>
<h4>配置方式：</h4>
<p><code># Set the swappiness value as root<br />
echo 10 &gt; /proc/sys/vm/swappiness<br />
# Alternatively, run this<br />
sysctl -w vm.swappiness=10<br />
#Permanent changes are made in /etc/sysctl.conf via the following configuration line (inserted, if not present):<br />
vm.swappiness = 10<br />
</code></p>
<h2>4、SWAP分区操作</h2>
<p>SWAP分区的操作分为：增加SWAP和停止SWAP分区。相关操作命令：<br />
mkswap(格式化分区)|swapon(激活分区 )|swapoff(停止swap分区)</p>
<h4>创建SWAP分区</h4>
<p>1、停止所有的swap分区<br />
<code># swapoff -a</code><br />
2、创建swap磁盘分区<br />
<code>#fdisk /dev/sdb</code><br />
swap分区的类型的id为82<br />
退出fdisk时使用w保存操作。<br />
3、格式化分区<br />
<code>#mkswap /dev/sdb2</code><br />
4、激活启动分区<br />
<code># swapon /dev/sdb2</code><br />
5、添加到系统自启动中/etc/fstab<br />
<code>/dev/sdb2 swap swap defaults 0 0</code></p>
<h4>使用文件创建SWAP分区</h4>
<p>1、使用dd命令创建swap分区文件，大小为1GB，bs输入输出块的大小，count定义块的数量<br />
<code># dd if=/dev/zero of=/root/swapfile bs=1M count=1024</code><br />
2.格式化为交换分区文件:<br />
<code># mkswap /root/swapfile</code><br />
3.启用交换分区文件:<br />
<code># swapon /root/swapfile</code><br />
4.使系统开机时自启用，在文件/etc/fstab中添加一行：<br />
<code>/root/swapfile swap swap defaults 0 0</code></p>
<h4>卸载SWAP分区</h4>
<p><code>#swapoff -a </code><br />
#停止所有的swap分区</p>
<h4>补充说明</h4>
<p><strong>kswapd0进程占用大量CPU</strong><br />
如果物理内存不够用，系统就会唤醒 kswapd0 进程，由 kswapd0 分配磁盘交换空间作缓存，因而占用大量的 CPU 资源。<br />
<strong>页面交换概念</strong><br />
paging 和 swapping 是两个完全不同的概念<br />
swapping：在操作系统里是指把某程序完全交换到硬盘以腾出内存给新程序使用<br />
paging：只交换程序的部分（页面）是两个不同的概念<br />
纯粹的 swapping 在现代操作系统中已经很难看到了，因为把整个程序交换到硬盘的办法既耗时又费力而且没必要，现代操作系统基本都是 paging 或者 paging/swapping 混合，swapping 最初是在 Unix system V 上实现的。</p>
<h4>缓冲和缓冲</h4>
<p>Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache<br />
Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。<br />
Free中的buffer和cache：（它们都是占用内存）</p>
            </div>
        </div>
        <!-- 文章内容结束 -->
    </article>


</main><!-- .content-area -->

<div class="footer">
    <div class="container">

<div class="has-text-centered">
Copyright©2015-20178 cn-blogs.cn. All Rights Reserved. 鲁ICP备18001334号-2
</div>
    </div>
  </div>

</body>
</html>
